## 1.ip首部结构信息
IP首部所有的数值都以网络字节序(大端序)存储

<img width="998" height="308" alt="image" src="https://github.com/user-attachments/assets/8105ddd9-88ca-41b5-8aaa-dd9ac53306a4" />


### 1.1 版本号
IP协议版本，**IPv4 为 4，	IPv6 为 6**
### 1.2 IHL首部长度
首部长度，**单位为4字节**，最小值为 5（即 20 字节，无 options）
### 1.3 DSCP/ECN 
- DSCP 是对原来 IPv4 TOS 字段的升级（RFC 2474），表示数据包的“服务类别”和优先级
- ECN 是 TCP/IP 协议中的一种拥塞控制机制（RFC 3168），当网络发生拥塞时，路由器/交换机会不丢包，而是设置 ECN 位，告诉双方网络拥塞了，请减小发送速率；
- 前提：双方都支持 ECN，且 TCP 协议协商成功
### 1.4 tot_len（Total Length）
整个 IP 数据报的长度（头+数据），最大 65535 字节
### 1.5 标识 id（Identification）
用于 IP 分片时标识同一个数据包，3 bits：DF（不分片）、MF（更多分片）
### 1.6 位偏移 frag_off（Fragment Offset）
指示该片在原始包中的位置
### 1.7 ttl（Time To Live）
- 控制数据包生存时间（防止死循环）
- 每过一个路由器减1，减为0则丢弃
### 1.8 protocol
指定数据部分的高层协议(传输层)类型：
- TCP: 6
- UDP: 17
- ICMP: 1
### 1.9 check（Header Checksum）
- 只校验 IP 头部，不包含数据
- 在转发时必须重新计算
### 1.10 saddr（Source Address）
源 IP 地址（32 位）
### 1.11 daddr（Destination Address）
目标 IP 地址（32 位）
### 1.12 options（可选字段）
- 用于调试、记录路径、安全性等
- 只有当 ihl > 5 时才有 options，字段长度可变

## 2.内核源码
> include/uapi/linux/ip.h
```c
struct iphdr {
#if defined(__LITTLE_ENDIAN_BITFIELD)
	__u8	ihl:4,
		version:4;
#elif defined (__BIG_ENDIAN_BITFIELD)
	__u8	version:4,
  		ihl:4;
#else
#error	"Please fix <asm/byteorder.h>"
#endif
	__u8	tos;
	__be16	tot_len;
	__be16	id;
	__be16	frag_off;
	__u8	ttl;
	__u8	protocol;
	__sum16	check;
	__struct_group(/* no tag */, addrs, /* no attrs */,
		__be32	saddr;
		__be32	daddr;
	);
	/*The options start here. */
};
```
## 3. 接收分组

>net/ipv4/ip_input.c  ip_rcv()
### 3.1 Netfilter 的 5 个 HOOK 点（IPv4）
#### 3.1.1 NF_INET_PRE_ROUTING
```c
/*
 * IP receive entry point
 */
int ip_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt,
	   struct net_device *orig_dev)
{
	struct net *net = dev_net(dev);

	skb = ip_rcv_core(skb, net);
	if (skb == NULL)
		return NET_RX_DROP;

	return NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING,
		       net, NULL, skb, dev, NULL,
		       ip_rcv_finish);
}
```
**<mark>NF_INET_PRE_ROUTING</mark>** : 数据包刚进入网络栈，还未进行路由<br>
如果是发送到本机 --> NF_INET_LOCAL_IN
```c
static int ip_rcv_finish(struct net *net, struct sock *sk, struct sk_buff *skb)
{
	struct net_device *dev = skb->dev;
	int ret;

	/* if ingress device is enslaved to an L3 master device pass the
	 * skb to its handler for processing
	 */
	skb = l3mdev_ip_rcv(skb);
	if (!skb)
		return NET_RX_SUCCESS;

	ret = ip_rcv_finish_core(net, skb, dev, NULL);
	if (ret != NET_RX_DROP)
		ret = dst_input(skb);
	return ret;
}
```

```c
INDIRECT_CALLABLE_DECLARE(int ip6_output(struct net *, struct sock *,
					 struct sk_buff *));
INDIRECT_CALLABLE_DECLARE(int ip_output(struct net *, struct sock *,
					 struct sk_buff *));
/* Output packet to network from transport.  */
static inline int dst_output(struct net *net, struct sock *sk, struct sk_buff *skb)
{
	return INDIRECT_CALL_INET(skb_dst(skb)->output,
				  ip6_output, ip_output,
				  net, sk, skb);
}

INDIRECT_CALLABLE_DECLARE(int ip6_input(struct sk_buff *));
INDIRECT_CALLABLE_DECLARE(int ip_local_deliver(struct sk_buff *));
/* Input packet from network to transport.  */
static inline int dst_input(struct sk_buff *skb)
{
	return INDIRECT_CALL_INET(skb_dst(skb)->input,
				  ip6_input, ip_local_deliver, skb);
}
```

#### 3.1.2 NF_INET_LOCAL_IN
如果是发送到本机：
```c
/*
 * 	Deliver IP Packets to the higher protocol layers.
 */
int ip_local_deliver(struct sk_buff *skb)
{
	/*
	 *	Reassemble IP fragments.
	 */
	struct net *net = dev_net(skb->dev);

	if (ip_is_fragment(ip_hdr(skb))) {
		if (ip_defrag(net, skb, IP_DEFRAG_LOCAL_DELIVER))
			return 0;
	}

	return NF_HOOK(NFPROTO_IPV4, NF_INET_LOCAL_IN,
		       net, NULL, skb, skb->dev, NULL,
		       ip_local_deliver_finish);
}
```

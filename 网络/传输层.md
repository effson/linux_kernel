## 1. 套接字类型
### 1.1 SOCK_STREAM
TCP,面向连接的可靠流
### 1.2 SOCK_DGRAM
UDP,无连接的数据报
### 1.3 SOCK_RAW
原始 IP,允许访问底层协议头,支持使用与协议无关的传输层格式收发数据
### 1.4 SOCK_RDM
可靠数据报（不常用），保证顺序但无连接（实验）
### 1.5 SOCK_SEQPACKET
有序可靠报文（面向连接），SCTP、UNIX seqpacket
### 1.6 SOCK_DCCP

## 2. 描述套接字API提供一些方法(内核源码)
> net/socket.c
```C
SYSCALL_DEFINE3(socket, int, family, int, type, int, protocol)
{
	return __sys_socket(family, type, protocol);
}

SYSCALL_DEFINE3(bind, int, fd, struct sockaddr __user *, umyaddr, int, addrlen)
{
	return __sys_bind(fd, umyaddr, addrlen);
}

SYSCALL_DEFINE3(accept, int, fd, struct sockaddr __user *, upeer_sockaddr,
		int __user *, upeer_addrlen)
{
	return __sys_accept4(fd, upeer_sockaddr, upeer_addrlen, 0);
}

SYSCALL_DEFINE3(connect, int, fd, struct sockaddr __user *, uservaddr,
		int, addrlen)
{
	return __sys_connect(fd, uservaddr, addrlen);
}

SYSCALL_DEFINE3(getsockname, int, fd, struct sockaddr __user *, usockaddr,
		int __user *, usockaddr_len)
{
	return __sys_getsockname(fd, usockaddr, usockaddr_len);
}

SYSCALL_DEFINE3(getpeername, int, fd, struct sockaddr __user *, usockaddr,
		int __user *, usockaddr_len)
{
	return __sys_getpeername(fd, usockaddr, usockaddr_len);
}

SYSCALL_DEFINE3(sendmsg, int, fd, struct user_msghdr __user *, msg, unsigned int, flags)
{
	return __sys_sendmsg(fd, msg, flags, true);
}

SYSCALL_DEFINE3(recvmsg, int, fd, struct user_msghdr __user *, msg,
		unsigned int, flags)
{
	return __sys_recvmsg(fd, msg, flags, true);
}
```
## 3.内核源码解析
### 3.1 struct socket

```c
struct socket {
	socket_state		state;
	short			type;
	unsigned long		flags;
	struct file		*file;
	struct sock		*sk;
	const struct proto_ops	*ops; /* Might change with IPV6_ADDRFORM or MPTCP. */
	struct socket_wq	wq;
};
```
#### 3.1.1 socket_state  state
枚举 socket_state（定义在 include/uapi/linux/net.h）,表示套接字当前的高层状态（面向用户态的状态），与 TCP 的 tcp_state 不同，这是通用套接字状态
```c
typedef enum {
	SS_FREE = 0,			/* not allocated		*/
	SS_UNCONNECTED,			/* unconnected to any socket	*/
	SS_CONNECTING,			/* in process of connecting	*/
	SS_CONNECTED,			/* connected to socket		*/
	SS_DISCONNECTING		/* in process of disconnecting	*/
} socket_state;
```
#### 3.1.2 short type
套接字类型，对应用户态 socket() 系统调用的第二个参数 type:
```c
enum sock_type {
	SOCK_STREAM	= 1,  //TCP，面向连接的字节流
	SOCK_DGRAM	= 2, //UDP，无连接数据报
	SOCK_RAW	= 3, // 原始 IP 数据包
	SOCK_RDM	= 4,
	SOCK_SEQPACKET	= 5, // 固定大小消息序列
	SOCK_DCCP	= 6,
	SOCK_PACKET	= 10,
};
```

#### 3.1.3 unsigned long  flags
套接字标志位，用于控制行为或标记状态
```c
#define SOCK_NOSPACE		2 // 发送缓冲区已满
#define SOCK_PASSCRED		3 // 接收者需要获取发送者的凭证
#define SOCK_PASSSEC		4 // 传递安全相关信息
```

#### 3.1.4 struct file	*file
指向该 socket 对应的 VFS 文件对象（struct file），当用户在用户态用 socket() 创建套接字时，内核会在 /proc/<pid>/fd/ 下分配一个文件描述符（fd），并关联到一个 struct file。
<mark>struct file->private_data</mark>会指向这个 struct socket.<br>

支持 VFS 层的文件操作（read、write、poll 等）映射到 socket 操作。文件描述符关闭时（close(fd)）会调用 socket 对应的 release 操作，最终释放 struct socket<br>
#### 3.1.5 struct sock	*sk
struct socket 是 socket 层抽象，struct sock 是 传输层/网络层的协议实例, 保存协议层特有的状态（TCP 状态机、发送队列、接收队列、定时器等）,所有数据收发最终都会落到这个 struct sock 上

#### 3.1.6  const struct proto_ops *ops
函数指针表，定义了该套接字的具体操作方法（connect、accept、sendmsg、recvmsg、shutdown 等
#### 3.1.7 struct socket_wq wq
socket 的等待队列，封装了 wait_queue_head_t 和异步通知机制
```c
struct socket_wq {
	/* Note: wait MUST be first field of socket_wq */
	wait_queue_head_t	wait;
	struct fasync_struct	*fasync_list;
	unsigned long		flags; /* %SOCKWQ_ASYNC_NOSPACE, etc */
	struct rcu_head		rcu;
} ____cacheline_aligned_in_smp;
```
- 支持阻塞 I/O：如 recv() 没有数据时进程会挂到这个等待队列
- 支持 select() / poll() / epoll() 等事件通知机制
- 支持信号驱动 I/O（SIGIO）
#### 3.1.8 总体关系图
```text
用户态 fd
   │
VFS: struct file  <----->  struct socket  <----->  struct sock (TCP/UDP/RAW)
            ↑                     ↑
        file->private_data   socket->sk
                              socket->ops -> 协议操作函数表
                              socket->wq  -> 等待队列
```

### 3.2 struct sock
> include/net/sock.h
```c
struct sock {
    struct sk_buff_head	sk_receive_queue; //接收队列（receive queue），保存已经到达但还没被用户态读取的数据包
	// ...
	int			sk_rcvbuf; //接收缓冲区大小，单位是字节, 超过该值时，内核会丢弃新到的数据包或进行流量控制
	int			sk_sndbuf; // 发送缓冲区大小，单位字节
	// ...
	struct sk_buff_head	sk_write_queue; // 发送队列
	void			(*sk_data_ready)(struct sock *sk); // 回调函数，当接收队列有新数据可读时触发
	void			(*sk_write_space)(struct sock *sk); // 回调函数，当发送缓冲区有空间可用时触发
}
```

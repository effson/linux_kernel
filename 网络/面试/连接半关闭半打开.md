# 1. 半打开状态
## 1.1 半连接
服务端在收到 第一个 SYN 并返回 SYN+ACK 之后，但还没等到客户端的最后一个 ACK 之前
### 半连接队列
用来存储半连接状态的连接，<mark>SYN队列, 通过哈希表实现</mark>
### 连接建立成功
移除半连接队列中的来连接，加入到全连接队列（accept队列）当中
### SYN flood、DDos攻击
客户端发了 SYN 但不回 ACK，半连接队列会被占满，导致正常请求被丢弃

### SYN包丢弃原理(客户端收到 SYN+ACK，不回复 ACK）
#### 半连接队列满了
- <mark>未启用 SYN Cookies</mark>
- 队列已满，Linux 内核默认策略丢弃新的 SYN 包，不回应 SYN+ACK

#### 全连接队列满了
- 服务端收到了客户端的 SYN，返回了 SYN+ACK，但客户端的最后 ACK 可能丢了
- 按照 TCP 协议，服务端会重传SYN+ACK（RTO 重传机制）
- 如果全连接队列已经满了，内核只会容忍前 1 次 SYN+ACK 重传
- 一旦重传次数超过 1，内核就直接把这个半连接丢掉（不再占用资源）
#### 未启用 SYN Cookies，syn队列长度大于3/4 tcp_max_syn_backlog，直接丢弃
- <mark>tcp_max_syn_backlog：内核参数，定义了半连接队列的最大长度</mark>
- 半连接队列使用率超过 75%,内核会认为 SYN 队列 过载，于是采取“直接丢弃新来的 SYN” 的策略
 
## 1.2 SYN Cookies
### 1.2.1 SYN Cookies 的作用
#### 防御 SYN Flood 攻击
- 不为半开连接分配任何资源，使用一种特殊方式验证客户端合法性
- 不在半连接队列里保存伪造的请求，避免资源被耗尽
- 即使攻击者发了上百万 SYN，只要不回 ACK，就不会占用服务器半连接队列
#### 提高连接建立成功率
- 在 SYN 队列已满时，正常客户端仍能成功完成三次握手

### 1.2.2 SYN Cookies 的原理
#### 计算"SYN Cookie"
- 计算一个特殊的 ISN（初始序列号），称为 cookie，写在 SYN+ACK 的 SEQ 字段中返回给客户端
- 这个 cookie 通常由以下信息加密组合而成：时间戳（避免重放）、MSS（客户端的最大报文段长度）、Hash(客户端 IP、端口、服务端 IP、端口、服务器的密钥)
#### 客户端回 ACK 时
- 客户端会把自己的 ACK = cookie + 1
- 服务端检查 ACK 是否符合 cookie 计算逻辑
- 验证通过 → 认为这是合法连接，才分配资源建立全连接

### 1.2.3 局限性
#### 由于 cookie 中只能编码有限信息，一些 TCP 选项无法在握手阶段保存 
#### 一旦使用 SYN Cookies，性能和兼容性会受到一定影响（部分 TCP 特性无法使用）

## 1.3. 防御SYN攻击
#### 启用 SYN Cookies
#### 扩大半连接队列
- 增大tcp_max_syn_backlog
- setsocketopt somaxconn：定义了 listen() backlog 的上限
- backlog，listen() 第二个参数， 决定了等待建立的连接队列长度

```c
int listen(int sockfd, int backlog);
```
#### 减少服务端SYN+ACK的重传次数
- 默认5次
- /proc/sys/net/ipv4/tcp_synack_retries设置为1
```bash
/home# cat /proc/sys/net/ipv4/tcp_synack_retries
5
```

```bash
/home# vim /etc/sysctl.conf
/home# sysctl -p
net.ipv4.tcp_synack_retries = 4
/home# cat /proc/sys/net/ipv4/tcp_synack_retries 
4
```

#### 开启tcp_syncookies
- /proc/sys/net/ipv4/tcp_syncookies
- 0 ：关闭 SYN Cookies，不使用
- 1 ：当 SYN 半连接队列溢出时，才启用 SYN Cookies（默认推荐值）
- 2 ：始终启用 SYN Cookies（即使半连接队列未满）

# 2. 半关闭状态
TCP 四次挥手中，第一次挥手就是典型的“进入半关闭状态”
## 客户端（主动断开端）
- 调用 close()， 发送 FIN

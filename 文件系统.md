# 1. struct file
表示一个被进程打开的文件实例
```c
struct file {
	union {
		struct callback_head 	f_task_work;
		struct llist_node	f_llist;
		unsigned int 		f_iocb_flags;
	};

	spinlock_t		f_lock;
	fmode_t			f_mode; // f_mode: 文件的打开模式（FMODE_READ, FMODE_WRITE, FMODE_LSEEK, FMODE_PREAD, FMODE_PWRITE, FMODE_EXCL, FMODE_NOCMTIME, FMODE_CAN_ODIRECT 等）。基于 open() 的 flags 参数设置
	atomic_long_t		f_count;
	struct mutex		f_pos_lock;
	loff_t			f_pos; //跟踪文件读写位置： 通过 f_pos 存储当前的文件偏移量
	unsigned int		f_flags;
	struct fown_struct	f_owner;
	const struct cred	*f_cred;
	struct file_ra_state	f_ra;
	struct path		f_path;  //包含指向该文件的目录项 (dentry) 和挂载点信息 (vfsmount) 的结构体 (struct path)
	struct inode		*f_inode;	/* cached value.核心指针！ 指向该文件对应的 struct inode（通常 f_path.dentry->d_inode 就是这个值） */ 
	const struct file_operations	*f_op; //核心指针！ 指向文件操作函数表 (struct file_operations) 的指针。这个指针通常在文件打开时从 inode->i_fop 复制而来

	u64			f_version;
#ifdef CONFIG_SECURITY
	void			*f_security;
#endif
	void			*private_data;

#ifdef CONFIG_EPOLL
	struct hlist_head	*f_ep;
#endif /* #ifdef CONFIG_EPOLL */
	struct address_space	*f_mapping; // 核心指针！ 指向该文件的地址空间 (struct address_space)，通常就是 inode->i_mapping。这是访问页缓存的入口
	errseq_t		f_wb_err;
	errseq_t		f_sb_err; /* for syncfs */
} __randomize_layout
  __attribute__((aligned(4)));	/* lest something weird decides that 2 is OK */

struct file_handle {
	__u32 handle_bytes;
	int handle_type;
	/* file identifier */
	unsigned char f_handle[] __counted_by(handle_bytes);
};
```

# 1. 半打开状态
## 1.1 半连接
服务端在收到 第一个 SYN 并返回 SYN+ACK 之后，但还没等到客户端的最后一个 ACK 之前
### 半连接队列
用来存储半连接状态的连接，<mark>SYN队列, 通过哈希表实现</mark>
### 连接建立成功
移除半连接队列中的来连接，加入到全连接队列（accept队列）当中
### SYN flood、DDos攻击
客户端发了 SYN 但不回 ACK，半连接队列会被占满，导致正常请求被丢弃

### SYN包丢弃原理(客户端收到 SYN+ACK，不回复 ACK）
#### 半连接队列满了
- <mark>未启用 SYN Cookies</mark>
- 队列已满，Linux 内核默认策略丢弃新的 SYN 包，不回应 SYN+ACK

#### 全连接队列满了
- 服务端收到了客户端的 SYN，返回了 SYN+ACK，但客户端的最后 ACK 可能丢了
- 按照 TCP 协议，服务端会重传SYN+ACK（RTO 重传机制）
- 如果全连接队列已经满了，内核只会容忍前 1 次 SYN+ACK 重传
- 一旦重传次数超过 1，内核就直接把这个半连接丢掉（不再占用资源）
#### 未启用 SYN Cookies，syn队列长度大于3/4 tcp_max_syn_backlog，直接丢弃
- <mark>tcp_max_syn_backlog：内核参数，定义了半连接队列的最大长度</mark>
- 半连接队列使用率超过 75%,内核会认为 SYN 队列 过载，于是采取“直接丢弃新来的 SYN” 的策略
 

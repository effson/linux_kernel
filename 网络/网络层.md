## 1.ip首部结构信息
IP首部所有的数值都以网络字节序(大端序)存储

<img width="998" height="308" alt="image" src="https://github.com/user-attachments/assets/8105ddd9-88ca-41b5-8aaa-dd9ac53306a4" />


### 1.1 版本号
IP协议版本，**IPv4 为 4，	IPv6 为 6**
### 1.2 IHL首部长度
首部长度，**单位为4字节**，最小值为 5（即 20 字节，无 options）
### 1.3 DSCP/ECN 
- DSCP 是对原来 IPv4 TOS 字段的升级（RFC 2474），表示数据包的“服务类别”和优先级
- ECN 是 TCP/IP 协议中的一种拥塞控制机制（RFC 3168），当网络发生拥塞时，路由器/交换机会不丢包，而是设置 ECN 位，告诉双方网络拥塞了，请减小发送速率；
- 前提：双方都支持 ECN，且 TCP 协议协商成功
### 1.4 tot_len（Total Length）
整个 IP 数据报的长度（头+数据），最大 65535 字节
### 1.5 标识 id（Identification）
用于 IP 分片时标识同一个数据包，3 bits：DF（不分片）、MF（更多分片）
### 1.6 位偏移 frag_off（Fragment Offset）
指示该片在原始包中的位置
### 1.7 ttl（Time To Live）
- 控制数据包生存时间（防止死循环）
- 每过一个路由器减1，减为0则丢弃
### 1.8 protocol
指定数据部分的高层协议(传输层)类型：
- TCP: 6
- UDP: 17
- ICMP: 1
### 1.9 check（Header Checksum）
- 只校验 IP 头部，不包含数据
- 在转发时必须重新计算
### 1.10 saddr（Source Address）
源 IP 地址（32 位）
### 1.11 daddr（Destination Address）
目标 IP 地址（32 位）
### 1.12 options（可选字段）
- 用于调试、记录路径、安全性等
- 只有当 ihl > 5 时才有 options，字段长度可变

## 2.内核源码
> include/uapi/linux/ip.h
```c
struct iphdr {
#if defined(__LITTLE_ENDIAN_BITFIELD)
	__u8	ihl:4,
		version:4;
#elif defined (__BIG_ENDIAN_BITFIELD)
	__u8	version:4,
  		ihl:4;
#else
#error	"Please fix <asm/byteorder.h>"
#endif
	__u8	tos;
	__be16	tot_len;
	__be16	id;
	__be16	frag_off;
	__u8	ttl;
	__u8	protocol;
	__sum16	check;
	__struct_group(/* no tag */, addrs, /* no attrs */,
		__be32	saddr;
		__be32	daddr;
	);
	/*The options start here. */
};
```
## 3. 接收与发送分组

>net/ipv4/ip_input.c  ip_output.c ip_forward.c
### 3.1 Netfilter 的 5 个 HOOK 点（IPv4）
#### 3.1.1 NF_INET_PRE_ROUTING
```c
/*
 * IP receive entry point
 */
int ip_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt,
	   struct net_device *orig_dev)
{
	struct net *net = dev_net(dev);

	skb = ip_rcv_core(skb, net);
	if (skb == NULL)
		return NET_RX_DROP;

	return NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING,
		       net, NULL, skb, dev, NULL,
		       ip_rcv_finish);
}
```
**<mark>NF_INET_PRE_ROUTING</mark>** : 数据包刚进入网络栈，还未进行路由<br>
如果是发送到本机 --> NF_INET_LOCAL_IN
```c
static int ip_rcv_finish(struct net *net, struct sock *sk, struct sk_buff *skb)
{
	struct net_device *dev = skb->dev;
	int ret;

	/* if ingress device is enslaved to an L3 master device pass the
	 * skb to its handler for processing
	 */
	skb = l3mdev_ip_rcv(skb);
	if (!skb)
		return NET_RX_SUCCESS;

	ret = ip_rcv_finish_core(net, skb, dev, NULL);
	if (ret != NET_RX_DROP)
		ret = dst_input(skb);
	return ret;
}
```

```c
INDIRECT_CALLABLE_DECLARE(int ip6_output(struct net *, struct sock *,
					 struct sk_buff *));
INDIRECT_CALLABLE_DECLARE(int ip_output(struct net *, struct sock *,
					 struct sk_buff *));
/* Output packet to network from transport.  */
static inline int dst_output(struct net *net, struct sock *sk, struct sk_buff *skb)
{
	return INDIRECT_CALL_INET(skb_dst(skb)->output,
				  ip6_output, ip_output,
				  net, sk, skb);
}

INDIRECT_CALLABLE_DECLARE(int ip6_input(struct sk_buff *));
INDIRECT_CALLABLE_DECLARE(int ip_local_deliver(struct sk_buff *));
/* Input packet from network to transport.  */
static inline int dst_input(struct sk_buff *skb)
{
	return INDIRECT_CALL_INET(skb_dst(skb)->input,
				  ip6_input, ip_local_deliver, skb);
}
```

#### 3.1.2 NF_INET_LOCAL_IN
如果是发送到本机：
```c
/*
 * 	Deliver IP Packets to the higher protocol layers.
 */
int ip_local_deliver(struct sk_buff *skb)
{
	/*
	 *	Reassemble IP fragments.
	 */
	struct net *net = dev_net(skb->dev);

	if (ip_is_fragment(ip_hdr(skb))) {
		if (ip_defrag(net, skb, IP_DEFRAG_LOCAL_DELIVER))
			return 0;
	}

	return NF_HOOK(NFPROTO_IPV4, NF_INET_LOCAL_IN,
		       net, NULL, skb, skb->dev, NULL,
		       ip_local_deliver_finish);
}
```

#### 3.1.3 NF_INET_FORWARD
```c
int ip_forward(struct sk_buff *skb)
{
	u32 mtu;
	struct iphdr *iph;	/* Our header */
	struct rtable *rt;	/* Route we use */
	struct ip_options *opt	= &(IPCB(skb)->opt);
	struct net *net;
	SKB_DR(reason);

	/* that should never happen */
	if (skb->pkt_type != PACKET_HOST)
		goto drop;

	if (unlikely(skb->sk))
		goto drop;

	if (skb_warn_if_lro(skb))
		goto drop;

	if (!xfrm4_policy_check(NULL, XFRM_POLICY_FWD, skb)) {
		SKB_DR_SET(reason, XFRM_POLICY);
		goto drop;
	}

	if (IPCB(skb)->opt.router_alert && ip_call_ra_chain(skb))
		return NET_RX_SUCCESS;

	skb_forward_csum(skb);
	net = dev_net(skb->dev);

	if (ip_hdr(skb)->ttl <= 1)
		goto too_many_hops;

	if (!xfrm4_route_forward(skb)) {
		SKB_DR_SET(reason, XFRM_POLICY);
		goto drop;
	}

	rt = skb_rtable(skb);

	if (opt->is_strictroute && rt->rt_uses_gateway)
		goto sr_failed;

	__IP_INC_STATS(net, IPSTATS_MIB_OUTFORWDATAGRAMS);

	IPCB(skb)->flags |= IPSKB_FORWARDED;
	mtu = ip_dst_mtu_maybe_forward(&rt->dst, true);
	if (ip_exceeds_mtu(skb, mtu)) {
		IP_INC_STATS(net, IPSTATS_MIB_FRAGFAILS);
		icmp_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED,
			  htonl(mtu));
		SKB_DR_SET(reason, PKT_TOO_BIG);
		goto drop;
	}

	/* We are about to mangle packet. Copy it! */
	if (skb_cow(skb, LL_RESERVED_SPACE(rt->dst.dev)+rt->dst.header_len))
		goto drop;
	iph = ip_hdr(skb);

	/* Decrease ttl after skb cow done */
	ip_decrease_ttl(iph);

	if (IPCB(skb)->flags & IPSKB_DOREDIRECT && !opt->srr &&
	    !skb_sec_path(skb))
		ip_rt_send_redirect(skb);

	if (READ_ONCE(net->ipv4.sysctl_ip_fwd_update_priority))
		skb->priority = rt_tos2priority(iph->tos);

	return NF_HOOK(NFPROTO_IPV4, NF_INET_FORWARD,
		       net, NULL, skb, skb->dev, rt->dst.dev,
		       ip_forward_finish);

sr_failed:
	 icmp_send(skb, ICMP_DEST_UNREACH, ICMP_SR_FAILED, 0);
	 goto drop;

too_many_hops:
	/* Tell the sender its packet died... */
	__IP_INC_STATS(net, IPSTATS_MIB_INHDRERRORS);
	icmp_send(skb, ICMP_TIME_EXCEEDED, ICMP_EXC_TTL, 0);
	SKB_DR_SET(reason, IP_INHDR);
drop:
	kfree_skb_reason(skb, reason);
	return NET_RX_DROP;
}
```
#### 3.1.4 NF_INET_LOCAL_OUT
ip_queue_xmit() 或 ip_build_and_send_pkt() → ip_output()
#### 3.1.5 NF_INET_POST_ROUTING
ip_finish_output()

## 1.accept创建新socket
> net/socket.c
```c
SYSCALL_DEFINE4(accept4, int, fd, struct sockaddr __user *, upeer_sockaddr,
		int __user *, upeer_addrlen, int, flags)
{
	return __sys_accept4(fd, upeer_sockaddr, upeer_addrlen, flags);
}
```
```c
int __sys_accept4(int fd, struct sockaddr __user *upeer_sockaddr,
		  int __user *upeer_addrlen, int flags)
{
  // fd: 监听套接字的文件描述符
	int ret = -EBADF;
	struct fd f;
  /*将用户空间传递进来的文件描述符 fd 转换为内核中的 struct fd 结构体
   * struct fd 包含了指向 struct file 对象的指针 (f.file)，而 struct
   * file 则代表内核中一个打开的文件实例，包含了文件操作函数集等信息
   */
	f = fdget(fd);
	if (f.file) {
		ret = __sys_accept4_file(f.file, upeer_sockaddr,
					 upeer_addrlen, flags);
		fdput(f);
	}
	return ret;
}
```
在一个监听套接字上接受一个新的连接。在之前的 __sys_accept4 函数中被调用:
```c
/* file: 指向监听 socket 的文件结构体（监听套接字） */
static int __sys_accept4_file(struct file *file, struct sockaddr __user *upeer_sockaddr,
			      int __user *upeer_addrlen, int flags)
{
	struct proto_accept_arg arg = { };
	struct file *newfile;
	int newfd;

	if (flags & ~(SOCK_CLOEXEC | SOCK_NONBLOCK))
		return -EINVAL;

	if (SOCK_NONBLOCK != O_NONBLOCK && (flags & SOCK_NONBLOCK))
		flags = (flags & ~SOCK_NONBLOCK) | O_NONBLOCK;

	// 分配新的文件描述符:
	newfd = get_unused_fd_flags(flags);
	if (unlikely(newfd < 0))
		return newfd;

	newfile = do_accept(file, &arg, upeer_sockaddr, upeer_addrlen,
			    flags);
	if (IS_ERR(newfile)) {
		put_unused_fd(newfd);
		return PTR_ERR(newfile);
	}
	/* 通过 fd_install() 将这个 newfile 安装为一个文件描述符，返回给应用程序 */
	fd_install(newfd, newfile);
	return newfd;
}
```
```c
struct file *do_accept(struct file *file, struct proto_accept_arg *arg,
		       struct sockaddr __user *upeer_sockaddr,
		       int __user *upeer_addrlen, int flags)
{
	struct socket *sock, *newsock;
	struct file *newfile;
	int err, len;
	struct sockaddr_storage address;
	const struct proto_ops *ops;

	/* 监听文件描述符 file 中提取出 struct socket *sock */
	sock = sock_from_file(file);
	if (!sock)
		return ERR_PTR(-ENOTSOCK);

	//为新连接分配一个 struct socket，即代表新连接的 socket
	newsock = sock_alloc();
	if (!newsock)
		return ERR_PTR(-ENFILE);
	//复制监听 socket 的类型（比如 SOCK_STREAM）
	ops = READ_ONCE(sock->ops);
	newsock->type = sock->type; 
	newsock->ops = ops; //复制其操作函数集（如 accept() 等）

	__module_get(ops->owner);

	/*为新 socket 分配一个 struct file *，这样
	 * 用户空间可以通过文件描述符访问这个 socket */
	newfile = sock_alloc_file(newsock, flags, sock->sk->sk_prot_creator->name);
	if (IS_ERR(newfile))
		return newfile;

	err = security_socket_accept(sock, newsock);
	if (err)
		goto out_fd;

	arg->flags |= sock->file->f_flags;
	/*调用协议栈的 accept() 方法（如 TCP 协议的 inet_accept()）
	 *来真正从监听队列中取出一个已完成连接，填充到 newsock*/
	err = ops->accept(sock, newsock, arg);
	if (err < 0)
		goto out_fd;

	if (upeer_sockaddr) {
		len = ops->getname(newsock, (struct sockaddr *)&address, 2);
		if (len < 0) {
			err = -ECONNABORTED;
			goto out_fd;
		}
		err = move_addr_to_user(&address,
					len, upeer_sockaddr, upeer_addrlen);
		if (err < 0)
			goto out_fd;
	}

	/* File flags are not inherited via accept() unlike another OSes. */
	return newfile;
out_fd:
	fput(newfile);
	return ERR_PTR(err);
}
```
